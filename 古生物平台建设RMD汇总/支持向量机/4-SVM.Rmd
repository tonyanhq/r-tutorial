---
title: "支持向量机SVM"
output: 
  html_document:
    number_sections: TRUE
    toc: TRUE
    toc_float: TRUE
    code_folding: show
    fig_width: 7
    fig_height: 4.5
    theme: united
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 概述
***
<font size=4 face="微软雅黑">
&emsp;&emsp;支持向量机(support vector machines, SVM) 是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划(convex quadratic programming)的问题。支持向量机的学习算法是求解凸二次规划的最优化算法。

&emsp;&emsp;支持向量机，其含义是通过支持向量运算的分类器。“机”的意思是机器，可以理解为分类器。

&emsp;&emsp;支持向量：在求解的过程中，会发现只根据部分数据就可以确定分类器，这些数据称为支持向量。

## 函数间隔与几何间隔

### 函数间隔
&emsp;&emsp;函数间隔：对于给定的训练数据集$T$和超平面$(w,b)$，定义超平面关于样本点$(x_i,y_i)$的函数间隔为

$$\hat{γ_i}=y_i(w x_i+b)$$


&emsp;&emsp;函数间隔可以表示分类预测的正确性及确信度。但是成比例地改变$w$和$b$ ，例如将它们改为$2w$和$2b$，超平面并没有改变，但函数间隔却成为原来的2倍。

<div align=center>
![](E:\PKU_R\nnet6.png)
</div>

&emsp;&emsp;对分离超平面的法向量、加某些约束，如规范化，$∥w∥=1$使得间隔是确定的。这时函数间隔成为几何间隔。

### 几何间隔
&emsp;&emsp;几何间隔：对于给定的训练数据集T和超平面$(w,b)$，定义超平面关于样本点$(x_i,y_i)$
的函数间隔为

$$γ_i=y_i(\frac{w}{||w||}・x_i+\frac{b}{||w||})$$
&emsp;&emsp;定义超平面$(w,b)$ 关于训练数据集T的函数间隔为超平面$(w,b)$ 关于T中所有样本点$(x_i,y_i)$函数间隔之最小值，即

$$γ=\min_{i=1,2,...,N}γ_i$$



&emsp;&emsp;函数间隔和几何间隔的关系:

<div align=center>
![](E:\PKU_R\nnet5.png)


</div>

&emsp;&emsp;如果超平面参数$w$ 和$b$ 
成比例地改变(超平面没有改变)，函数间隔也按此比例改变，而几何间隔不变。

### 什么是超平面

&emsp;&emsp; n维空间中的超平面由下面的方程确定:  $$w^Tx+b=0$$
                                                 
&emsp;&emsp;其中，$w$ 和 $x$ 都是 n 维列向量，$x$ 为平面上的点，$w$ 为平面上的法向量，决定了超平面的方向，$b$是一个实数，代表超平面到原点的距离。且 $$x=(x_1,x_2,...,x_d)^T$$
$$w=(w_1,w_2,...,w_d)^T$$

&emsp;&emsp;那么，$w$为什么是法向量呢？$b$为什么表示平面到原点的距离呢？下面给出详细解释：

&emsp;&emsp;我们对“平面”概念的理解，一般是定义在三维空间中的，即$Ax+By+Cz+D=0$

&emsp;&emsp;这个平面由两个性质定义：1、方程是线性的，是由空间点的各分量的线性组合。2、方程数量是1。  
&emsp;&emsp;这个平面是建立在“三维”上的。如果我们撇开“维度”这个限制，那么就有了超平面的定义。实际上，超平面是纯粹的数学概念，它是平面中的直线、空间中的平面的推广，只有当维度大于3，才称为“超”平面。它的本质是自由度比空间维度小1。自由度的概念可以简单的理解为至少要给定多少个分量的值才能确定一个点。   
&emsp;&emsp;例如, 三维空间里的(超)平面只要给定了$(x,y,z)$中任意两个分量, 剩下的一个的值就确定了. 先确定值的两个分量是自由的, 因为它们想取什么值就能取什么值;剩下的那个是”不自由的”, 因为它的值已经由另外两确定了。 二维空间里的超平面为一条直线。一维空间里超平面为数轴上的一个点。

&emsp;&emsp;超平面$H$是从n维空间到n-1维空间的一个映射子空间，它有一个n维向量和一个实数定义。因为是子空间，所以超平面一定过原点。  

### 间隔最大化

&emsp;&emsp;支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对线性可分的训练数据集而言，线性可分分离超平面有无穷多个(等价于感知机)，但是几何间隔最大的分离超平面是唯一的。这里的间隔最大化又称为硬间隔最大化。

&emsp;&emsp;间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类，也就是说，不仅将正负实例点分开，而且对最难分的实例点(离超平面最近的点)也有足够大的确信度将它们分开。

## VC维与结构风险最小原理
&emsp;&emsp;支持向量机方法是建立在统计学习理论的VC维理论和结构风险最小原理基础上的。

&emsp;&emsp;置信风险： 分类器对 未知样本进行分类，得到的误差。  
&emsp;&emsp;经验风险： 训练好的分类器，对训练样本重新分类得到的误差。即样本误差  
&emsp;&emsp;结构风险：置信风险 + 经验风险  
&emsp;&emsp;结构风险最小化就是为了防止过拟合而提出来的策略，贝叶斯估计中最大后验概率估计就是结构风险最小化的一个例子。当模型的条件概率分布、损失函数是对数损失函数、模型复杂度由模型先验概率表示时，结构风险最小化等价于最大后验概率估计。监督学习问题变成经验风险或结构风险函数的最优化问题，这时经验风险或结构风险函数是最优化的目标函数。  

&emsp;&emsp;SVM在小样本训练集上能够得到比其它算法好很多的结果。支持向量机之所以成为目前最常用，效果最好的分类器之一，在于其优秀的泛化能力，这是是因为其本身的优化目标是结构化风险最小，而不是经验风险最小，因此，通过margin的概念，得到对数据分布的结构化描述，因此减低了对数据规模和数据分布的要求。SVM也并不是在任何场景都比其他算法好，对于每种应用，最好尝试多种算法，然后评估结果。如SVM在邮件分类上，是不如逻辑回归、KNN、bayes效果好的。

### VC维
&emsp;&emsp;VC维：将N个点进行分类，如分成两类，那么可以有2^N^种分法，即可以理解成有2^N^个学习问题。若存在一个假设H，能准确无误地将2^N^种问题进行分类。那么这些点的数量N，就是H的VC维。 这个定义真生硬，只能先记住。一个实例就平面上3个点的线性划分的VC维是3. 而平面上 VC维不是4，是因为不存在4个样本点，能被划分成2^4^ = 16种划分法，因为对角的两对点不能被线性划分为两类。更一般地，在r 维空间中，线性决策面的VC维为r+1。  

### 结构风险最小
&emsp;&emsp;结构风险最小化SRM(structured risk minimize)就是同时考虑经验风险与结构风险。在小样本情况下，取得比较好的分类效果。**保证分类精度（经验风险）的同时，降低学习机器的 VC 维**，可以使学习机器在整个样本集上的期望风险得到控制，这是SRM的原则。

&emsp;&emsp;当训练样本给定时，分类间隔越大，则对应的分类超平面集合的 VC 维就越小。（分类间隔的要求，对VC维的影响）

&emsp;&emsp;根据结构风险最小化原则，前者是保证经验风险（经验风险和期望风险依赖于学习机器函数族的选择）最小，而后者使分类间隔最大，导致 VC 维最小，实际上就是使推广性的界中的置信范围最小，从而达到使真实风险最小。

&emsp;&emsp;训练样本在线性可分的情况下，全部样本能被正确地分类，即经验风险Remp 为 0 的前提下，通过对分类间隔最大化，使分类器获得最好的推广性能。

&emsp;&emsp;对于线性不可分的状况，可以允许错分。即对于离群点降低分类间隔。将距离原来的分类面越远，离群就越严重，这个距离，可以用一个值--松弛变量来表示，只有离群点才有松弛变量。当然，要对这个值加以限制，即在最小化函数里，加入一个惩罚项，里面还有一个可以人为设定的惩罚项C。当C无限的大，那么就退化为硬间隔问题，不允许有离群点，问题可能无解。若C=0，无视离群点。有时C值需要多次尝试，获取一个较好的值。 

## 核函数

&emsp;&emsp;原始特征是线性不可分的，但是通过对原始特征进行高斯变换之后，得到的新特征就是线性可分的了，这就是对核函数最直接的理解。下面介绍几种常用的核函数：

### 线性核函数

&emsp;&emsp;线性核函数是最简单的核函数，是径向基核函数的一个特例，公式为：

$$K(x,z)=x^Ty+c$$

&emsp;&emsp;主要用于线性可分的情形，在原始空间中寻找最优线性分类器，具有参数少速度快的优势。

### 多项式核函数

&emsp;&emsp;多项式核适合于正交归一化数据，公式为：

$$K(x,z)=(x z+1)^p$$
&emsp;&emsp;多项式核函数属于全局核函数，允许相距很远的数据点对核函数的值有影响。参数p 越大，映射的维度越高，计算量就会越大。当p过大时，学习复杂性也会过高，易出现过拟合。

### 径向基核函数

&emsp;&emsp;径向基核函数属于局部核函数，当数据点距离中心点变远时，取值会变小，公式为：

$$K(x,z)=exp(-γ∥x-z∥^2)$$

### 高斯核函数

&emsp;&emsp;高斯核函数可以看作是径向基核函数的另一种形式：

$$K(x,z)=exp(-\frac{‖x-z‖^2}{2σ^2})$$
&emsp;&emsp;高斯(径向基)核对数据中存在的噪声有着较好的抗干扰能力，由于其很强的局部性，其参数决定了函数作用范围，随着参数σ的增大而减弱。

# R中的实现
***
<font size=4 face="微软雅黑">

## **相关软件包**
<font size=4 face="微软雅黑">
&emsp;&emsp;本章将介绍R语言中用于支持向量机建模及分析的e1071软件包，其主要用于构建支持向量机的模型，提供核心函数svm()来建立支持向量机的基础模型，并且可以辅助使用predict()函数以及fitted()函数来进行分类。

&emsp;&emsp;R语言给我们提供了丰富的网上学习资源，包括软件包的使用说明文档、函数源代码、操作示例文档等，具体可以参考 http://cran.r-project.org/web/packages/e1071/index.html ，其中有相关链接。

&emsp;&emsp;下载安装相应软件包，加载后即可使用。
```{r}
library(e1071)             # 加载e1071软件包
```

</font>

## **核心函数介绍**  {.tabset .tabset-fade .tabset-pills}
<font size=4 face="微软雅黑">

### `svm()`函数

&emsp;&emsp;函数svm()是用来建立支持向量机模型的核心函数，可以用来建立一般情况下的回归模型，也可以用来建立判别分类模型以及密度估计模型。

&emsp;&emsp;`svm()`函数的使用格式有两种，一种是公式型，另一种是矩阵与向量型。

第一种函数使用格式：
```
svm(formula, data = NULL, ..., subset, na.action = na.omit, scale = TRUE)
```

&emsp;&emsp;其中，formula对于的是函数模型的形式，例如y~.  或者 y~a+b；data代表的是在模型中包含的有变量的一组可选格式的数据。


第二种函数使用格式：
```
svm(x, y = NULL, scale = TRUE, type = NULL, 
    kernel = "radial", degree = 3, gamma = if (is.vector(x)) 1 else 1 / ncol(x), 
    coef0 = 0, cost = 1, nu = 0.5, class.weights = NULL, 
    cachesize = 40, tolerance = 0.001, epsilon = 0.1, shrinking = TRUE, 
    cross = 0, probability = FALSE, fitted = TRUE, ..., subset, na.action = na.omit)
```
&emsp;&emsp;其中，x可以是一个矩阵，也可以是一个向量，还可以是稀疏矩阵；y是x的结果标签，既可以是字符向量也可是数量向量。

&emsp;&emsp;type是指建立模型的类别。支持向量机模型可以分为分类模型、回归模型或异常检测模型。所以在svm()函数中的type可以取的值有：C-classification、nu-classification、one-classification、eps-regression、nu-regression。在这5种类型中，前3种是针对字符型结果变量的分类方式，第三种为逻辑判别，后两种为针对数量型结果变量的分类方式。

&emsp;&emsp;kernel是指在模型建立过程中使用的核函数。如前文所述，支持向量机模型的建模过程中为了解决线性不可分的问题，提高预测精度，通常会使用核函数对原始特征进行变换，提高原始特征维度，解决支持向量机模型线性不可分的问题。kernel有4个可选核函数，分别是线性核函数linear、多项式核函数polynomial、径向基核函数（也称高斯核函数）radial basis以及神经网络核函数sigmoid。根据相关研究，识别率最高、性能最好的是径向基核函数，其次是多项式核函数，最差的是神经网络核函数。

&emsp;&emsp;核函数主要有两种类型――局部性核函数和全局性核函数，径向基核函数是局部性核函数，而多项式核函数是一个全局性核函数。局部性核函数仅仅在测试点附近小邻域内对数据有影响，学习能力强，泛化性能较弱；全局性核函数则相对泛化性能强，学习能力弱。

&emsp;&emsp;degree参数指的是核函数多项式内积函数的参数，默认为3；  
&emsp;&emsp;gamma参数值核函数中除去线性内积函数以外的所有函数的参数，默认为1；  
&emsp;&emsp;coef0参数指的是核函数中多项式内积函数与sigmoid内积函数中的参数，默认为0；  
&emsp;&emsp;nu参数指的是用于nu-classification、nu-regression和one-classification回归类型中的参数。

&emsp;&emsp;模型输出结果中的SV即support vector， 指的是支持向量机模型中最核心的支持向量。

&emsp;&emsp;Index所包含的结果是模型中支持向量在样本数据中的位置，简而言之就是支持向量是样本数据的第几个样本。

&emsp;&emsp;注意，在利用svm()函数建立支持向量机模型是，使用标准化之后的数据建立模型的效果更好。


### `plot()`函数

&emsp;&emsp;将svm()函数所得的支持向量机模型绘图，使用的是plot()函数，可以还是你刚才一个来自于根据各个类别和支持向量机建立的支持向量分类模型的输入数据散点图，同时还可以绘制出各个类别的分类图。

&emsp;&emsp;plot()函数在应用于svm()函数输出结果时的基本使用格式如下：
```
plot(x, data, formula, fill = TRUE, grid = 50, slice = list(), 
     symbolPalette = palette(), svSymbol = "x", dataSymbol = "o", ...)
```

&emsp;&emsp;其中：  
・x：svm()函数所建立的支持向量机模型  
・data：绘制支持向量机分类图所采用的数据，该数据格式应与模型建立过程中使用的数据格式一致。  
・formula参数：观察两个维度对模型分类的相互影响  
・fill参数：扩及参数，可以选TRUE或FALSE。当取TRUE时，绘制的图像有背景色，取FALSE为没有  
・symbolPalette参数：决定分类点及支持向量的颜色  
・svSymbol参数：决定支持向量的形状  
・dataSymbol参数：决定数据散点图的形状  


## **数据集**
<font size=4 face="微软雅黑">

&emsp;&emsp;本章我们使用datasets软件包中的iris数据集进行演示，我们首先对其进行简单的了解。
```{r}
data(iris)  # 获取数据集iris
summary(iris) # 获取iris数据集的概况信息
```

&emsp;&emsp;在获取完以上信息之后，我们来看iris数据集的基本信息。它一共包含150个样本以及4个样本特征，其中结果标签中总共具有三种类别，并且三种类别均有50个样本，所占比重相同。在输出的结果中还显示了样本的最小值、四分之一分位点、中位数、均值、四分之三分位点以及最大值。

&emsp;&emsp;在输出结果中，setosa、versicolor和virginica是鸢尾花所属的三种类别。本数据采集了这三种花的四项基本特征，分别为：花萼长度、花萼宽度、花瓣长度和花瓣宽度。

&emsp;&emsp;本章节主要介绍如何根据这四个特征来建立支持向量机模型，实现对三种花进行判别分类。

# 应用案例
***
<font size=4 face="微软雅黑">

&emsp;&emsp;先我们使用R语言来构建支持向量机模型分析iris数据集，查看模型的预测能力。

## **数据初探**
&emsp;&emsp;在对数据有了一定了解之后，我们首先要做的是确定需要建立的模型的基本形式。

&emsp;&emsp;可以看到，数据集中的Species是支持向量机模型中的结果标签，对应的部分分别是Swpal.Length、Sepal.Width、Petal.Length以及Petal.Width。所以我们建立模型的简单公式可以大概分为Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width。在接下来的建模过程中，我们将围绕这个公式进行分析。

## **建立模型**
&emsp;&emsp;在前面的介绍中我们了解到，svm()函数在建立支持向量分类机模型的时候有两种建立方式。一种是根据既定公式建立模型，另一种是根据数据建立模型。下面我们将从这两种建模过程分别出发，依次讲述建模过程。

&emsp;&emsp;根据函数的第一种使用格式，我们在建模时，需要首先确定所建立模型里使用的数据，然后确定模型的结果变量和特征变量。过程如下：

```{r}
svmModel <- svm(Species ~ ., data = iris)  # 构建svm模型
```

&emsp;&emsp;根据函数的第二组使用格式，首先需要把结果变量和特征变量分别提取出来。结果向量用向量表示，特征向量用矩阵表示。在确定好数据后应该根据数据分析所使用的核函数以及核函数所对应的参数值，通常默认使用高斯内积函数作为核函数。过程如下：

```{r}
x = iris[, -5]  # 提取iris数据中除去第5列以外的数据作为特征变量
y = iris[, 5]   # 提取iris数据中的第5列作为结果变量
svmModel <- svm(x, y, kernel = "radial", gamma = if(is.vector(x))1 else 1/ncol(x))  # 建立svm模型
```
&emsp;&emsp;在使用第二种格式建立模型时，不需要特别强调所建立模型的形式，函数会自动将所有输入的特征变量数据作为建立模型所需要的特征向量。

&emsp;&emsp;在上述过程中，确定核函数的gamma系数时所使用的R语言所代表的含义为：如果特征向量是向量，则gamma取值为1，否则gamma值是特征向量个数的倒数。

## **结果分析**

```{r}
summary(svmModel)  # 查看支持向量机模型的相关结果
```

&emsp;&emsp;通过summary()函数可以得到关于模型的相关信息。其中，SVM-Type说明构建的模型的类别是C分类器模型；SVM-Kernel说明模型所使用的核函数为高斯内积函数且核函数中gamma取值为0.25；cost说明模型确定的约束违反成本为1.

&emsp;&emsp;在输出结果中，模型找到了51个支持向量，并划分为了3类，每一类支持向量的个数分别为8个、22个和21个。Levels说明模型中三个分类分别是setosa、versicolor和virginica。

## **预测判别**
&emsp;&emsp;通常我们利用样本数据构建模型之后，主要目的是利用模型来进行相应的预测和判别。在用svm()函数构建模型进行预测时，我们将用到R语言自带的predict()函数进行预测。在进行预测之前，首先要确定用于预测的样本数据，并将样本数据的特征变量整合放入同一个矩阵。操作如下：
```{r}
x <-  iris[, 1:4]             # 确认需要进行预测的样本特征矩阵
pred <- predict(svmModel, x)  # 根据模型对x进行预测
pred[sample(1:150, 8)]        # 随机挑选8个预测结果进行展示
```
&emsp;&emsp;在进行预测时，主要要注意必须保证预测的特征向量个数应该与建立模型时的特征向量个数一致，否则会报错。在使用predict()函数时不用刻意调整预测结果类型。

&emsp;&emsp;通过上述预测结果展示，可以看到predict()函数在预测时自动识别预测结果的类型，并自动生成了相应的类别名称。通知进行预测之后，还需要检查模型预测的精度，这需要用table()函数展示进行预测结果与实际结果的对比。结果如下：

```{r}
table(pred, y)  # 模型预测精度展示
```

&emsp;&emsp;通过观察table()函数对模型预测精度的展示结果，我们可以看到，模型在预测时将所有属于setosa类型的花全部预测正确，属于versicolor类型的花中48朵预测正确，但将另外2朵预测为virginica类型，属于virginica类型的花中48朵预测正确，但将另外2朵预测为versicolor类型。

## **综合建模**

&emsp;&emsp;通过上述对支持向量机理论及支持向量机模型在R语言中的具体应用介绍，我们将整理前面的内容，基于iris数据集综合介绍利用R语言建立模型的完整过程。

&emsp;&emsp;分析数据可以看出，数据需要判别3个类型，而且三个类别属于字符型，属于我们可以选择的支持向量分类机共有3类：C-classification、nu-classification和one-classification。同时，可以选择的核函数共有4类：线性核函数（linear）、多项式核函数（polynomial）、径向基核函数（radialbasis，RBF）和神经网络核函数（sigmoid）。所以在时间和精力允许的情况下，应该尽可能地建立所有模型，最后比较得到最佳模型。根据上述分析，实现过程如下。

```{r}
attach(iris)     # 将数据集iris按列确认为向量
x <- subset(iris, select = -Species)  # 确定特征变量为iris除去Species的对象
y <- Species               # 确定结果变量为iris中的Species项
type <- c("C-classification", "nu-classification", "one-classification")  # 确定将要使用的分类方式
kernel <- c("linear", "polynomial", "radial", "sigmoid")     # 确定将要使用的核函数
pred <- array(0, dim = c(150, 3, 4))             # 初始化预测结果矩阵的三维长度分别为150,3,4
accuracy <- matrix(0, 3, 4)          # 初始化模型精准度矩阵的两维分别为3和4
yy <- as.integer(y)              # 为方便模型精度计算，将结果变量数量化为1,2,3
for(i in 1:3)  {               # 确定i影响的维度代表分类方式
  for (j in 1:4) {
    pred[, i, j] <- predict(svm(x, y, type = type[i], kernel = kernel[j]), x)   # 对每一个模型进行预测
    if(i>2)  accuracy[i, j] <- sum(pred[, i, j] != 1)
    else    accuracy[i, j] <- sum(pred[, i, j] != yy)
  }
}
dimnames(accuracy) <- list(type, kernel)   # 确定模型精度变量的列名和行名
```

&emsp;&emsp;在运行结果中，使用if语句进行不同预测精度的运算。最后得到所有12个模型的预测精度，accuracy代表的是模型预测错误的个数。

&emsp;&emsp;根据预测结果挑选出预测错误较少的模型，根据实际情况进行分析，得到最适合的模型

&emsp;&emsp;相应的预测结果如下：

--| linear | Polynomial | Radial | Sigmoid
-- | ----- | ---------- | ------ | -------
C-classification | 5 | 7 | 4 | 17
nu-classification | 5 | 14 | 5 | 12
one-classification | 102 | 75 | 76 | 75

&emsp;&emsp;从表中我们可以看出，利用C-classification与高斯核函数结合的模型判别错误最少。下面我们将利用C-classification和高斯核函数结合的模型预测结果列出：

```{r}
table(pred[, 1, 3], y)   # 模型预测精度展示
```

&emsp;&emsp;得到这个较优的模型之后，我们将针对这个模型进行具体的分析与讨论，力图进一步提高模型的预测精度。

## **可视化分析**

&emsp;&emsp;在建立支持向量机模型之后，我们还需要对模型进行进一步分析，为了便于分析，我们将用plot()函数对模型信息可视化。
```{r}
plot(cmdscale(dist(iris[, -5])), 
     col = c("red", "blue", "green")[as.integer(iris[, 5])], 
     pch = c("o", "+")[1:150 %in% svmModel$index + 1])       # 绘制模型分类散点图
legend(2.2, -0.5, c("setosa", "versicolor", "virginica"),
       col = c("red", "blue", "green"), lty = 1)     # 图例标注
```

&emsp;&emsp;通过plot()函数对支持向量机进行可视化之后，得到的图形是对模型数据类别的一个总体观察。图中的“+”表示支持向量，“o”表示普通样本点。

&emsp;&emsp;由上图我们可以看到，setosa与其他两种差别较大，versicolor与virginica的差别较小。这也能够说明预测过程中出现问题的原因。

&emsp;&emsp;我们还可以利用plot()函数对模型类别关于模型中任意两个特征向量的变动过程进行绘图，具体过程如下；

```{r}
svmModel <- svm(Species ~ ., data = iris)         # 利用公式格式建立模型
plot(svmModel, iris, Petal.Width ~ Petal.Length, fill = FALSE, 
     symbolPalette = c("red", "blue", "green"), svSymbol = "+")   # 绘制模型类别关于花瓣宽度与长度的分类情况
legend(1, 2.5, c("setosa", "versicolor", "virginica"), 
       col = c("red", "blue", "green"), lty = 1)    # 图例标注
```

&emsp;&emsp;通过对花瓣宽度和长度可视化之后，可以得到：setosa类别与另外两种相差较大，versicolor与virginica相差较小。virginica的花瓣长度和宽度总体上高于其他两种，versicolor的花瓣长度和宽度处于居中位置，setosa的花瓣长度和宽度小于另外两种。

## **优化建模**
&emsp;&emsp;我们可以看到，尽管预测错误已经很少，但是否存在一个最优的支持向量机模型，使得预测错误减少至0呢？

&emsp;&emsp;通过对模型的可视化分析，无论从总体还是个别特征的角度观察，setosa与其他两种差异较大，另外两种差异较小。模型预测中出现错误的部分也是相似的两种类别。

&emsp;&emsp;因此，我们与通过改变模型各个类别的比重来进行数据调整。由于setosa同其他两种类别相差较大，所以我们可以考虑降低setosa在模型中的比重，提高另外两种类别的比重，牺牲setosa的精度来提高versicolor和virginica的精度。这种方法可以通过svm中的class.weights参数进行调整。注意，class.weights参数需要的数据为具有列名的向量。

```{r}
wts <- c(1,1,1)    # 确定模型中每个类别的比重相同
names(wts) <- c("setosa", "versicolor", "virginica")   # 确定各个比重对应的类别
svmModel1 <- svm(x, y, class.weights = wts)     # 构建比重相同的支持向量机模型
```

&emsp;&emsp;当模型各个类别比重相同，是支持向量机最原始的模型，预测结果与上面所述相同。接下来我们将比重进行调整，观察预测精度是否发生变化，是否为积极的影响。

```{r}
wts <- c(1, 50, 50)   # 将每个分类的比重更改为1:100:100
names(wts) <- c("setosa", "versicolor", "virginica")   # 确定各个比重对应的类别
svmModel2 <- svm(x, y, class.weights = wts)     # 构建比重相同的支持向量机模型
pred2 <- predict(svmModel2, x)            # 根据模型进行预测
table(pred2, y)                           # 展示预测结果
```

&emsp;&emsp;通过预测结果的展示，降低setosa的比重确实能影响预测精度，并且是积极的影响。我们继续改变权重来提高模型的精度。

&emsp;&emsp;我们将两个类别的权重继续扩大10倍，即比原始权重扩大500倍，过程如下：
```{r}
wts <- c(1, 500, 500)   # 将每个分类的比重更改为1:100:100
names(wts) <- c("setosa", "versicolor", "virginica")   # 确定各个比重对应的类别
svmModel3 <- svm(x, y, class.weights = wts)     # 构建比重相同的支持向量机模型
pred3 <- predict(svmModel3, x)            # 根据模型进行预测
table(pred3, y)                           # 展示预测结果
```

&emsp;&emsp;经过权重调整，所有样本的预测全部正确。因此必要的时候可以通过改变各类样本的权重比例来提高模型预测精度。

# 本章汇总
***
<font size=4 face="微软雅黑">

名称 | 类别 | 功能
---- | ---- | ------
e1071  | 软件包 | 用于支持向量机模型    
iris | 数据集  | r语言中用于数据挖掘的数据包  
svm() | 函数 | 利用数据构建支持向量机模型
summary() | 函数 | 查看模型的相关信息
predict() | 函数 | 对模型进行预测
plot() | 函数 | 绘制支持向量机图

# 参考文献
***
<font size=4 face="微软雅黑">
[1] 周志华. 机器学习 : = Machine learning[M]. 清华大学出版社, 2016.  
[2] 黄文, 王正林. 数据挖掘 : R语言实战[M]. 电子工业出版社, 2014.  
[3] 加雷斯・詹姆斯, GarethJames, 詹姆斯,等. 统计学习导论:基于R应用[M]. 机械工业出版社, 2015.  
[4] 葫芦赛赛. 结构化风险最小、VC维到SVM的理解[DB/OL].  https://blog.csdn.net/huruzun/article/details/41795325 ,2014-12-08/2018-06-08.